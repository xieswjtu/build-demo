**["1","2","3"].map(pareseInt)的运行结果**
执行 ["1","2","3"].map(parseInt) 会返回 [1, NaN, NaN]，而不是期望的 [1, 2, 3]。
原因：
map 方法会传递 3 个参数给回调函数：
当前元素的值（如 "1", "2", "3"）。
当前元素的索引（0, 1, 2）。
数组本身（["1", "2", "3"]）。
但是，parseInt 函数接收两个参数：

字符串（需要解析的值）。
基数（radix），即解析数字时使用的进制。
当 map 传递元素时，parseInt 把第二个参数——即 map 中的索引——当作了 radix，导致以下解析结果：

parseInt("1", 0)：基数为 0 时，parseInt 自动使用 10 进制解析，结果是 1。
parseInt("2", 1)：基数 1 是无效的，因此返回 NaN。
parseInt("3", 2)：基数 2 表示二进制，但 "3" 不是一个有效的二进制数字，因此返回 NaN。
解决方法：
正确的做法是明确地只传递第一个参数给 parseInt，可以通过使用箭头函数或者直接定义回调函数：

["1", "2", "3"].map(num => parseInt(num));
// 或者
["1", "2", "3"].map(parseInt.bind(null));
这会确保 parseInt 只接收到正确的参数，返回 [1, 2, 3]。


**事件传播的三个阶段目标捕获冒泡  按顺序是怎么样的**
“事件传播”在前端开发中，尤其是在浏览器中的 DOM 事件处理中，通常会涉及三个阶段：捕获阶段、目标阶段 和 冒泡阶段。按顺序是：

捕获阶段（Capture Phase）： 在这一阶段，事件从 DOM 树的根节点（document）开始，一路向下传递，直到传递到目标元素。此时，事件还没有真正触发处理器，而是沿着 DOM 树向下进行“捕获”式传播。你可以在捕获阶段通过 addEventListener 的第三个参数设置为 true 来捕获事件。
顺序：document -> body -> ... -> 目标元素

目标阶段（Target Phase）： 当事件到达目标元素时，就进入了目标阶段。此时，事件会在目标元素上触发。目标阶段是事件处理的核心，它标志着事件触发的实际位置。此阶段不会传递，事件只在目标元素上执行。

冒泡阶段（Bubble Phase）： 冒泡阶段是事件传播的最后一个阶段。事件从目标元素开始，沿着 DOM 树逐级向上传递，直到传播回到 document。与捕获阶段相反，冒泡阶段的事件传播是从目标向上层父元素逐步传递。默认情况下，事件监听器会在冒泡阶段触发，但你也可以通过 stopPropagation() 来阻止冒泡。