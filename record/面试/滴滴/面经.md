# 面经1
面试官人很好，算法题写不出来会慢慢引导
**1.vue diff算法**
2.组件通信方式
3.浅拷贝/深拷贝
浅拷贝：Object.assgin(),{...obj}对象
array.slice(),[...arry]数组
3.发布订阅&amp;其他设计模式
4.输入url到呈现页面的过程
5.csrf/xss攻击防御
6.dos攻击防御
7.浏览器缓存
8.http状态码
**9.webpack的理解？打包过程**
10.手撕：字符串全排列
11.平时有没有关注前端最新动态
12.反问

## 面经2
1.TLS四次握手
2.node事件循环
3.fork和vfork
4.Linux和window系统的内存管理区别
5.虚拟内存介绍
6.Vue differ原理
7.Vue.nextTick功能和实现
8.手写题目
实现一个函数，传入一个Promise的数组，实现数组内的顺序链式调用，我的方法就是遍历+await
手写一个异步相关的输出题，涉及到Promise没有resolve情况，和node相关异步调用

## 面经3
1.项目题: 把你简历里的大文件上传+大文件分片在IDE里写一遍 我: 6
2.闭包是什么? 写一个闭包的例子 
3.浏览器垃圾回收机制
3plus. 怎么监听内存泄漏
3plus+. 开发时有什么办法减少内存泄露
**4.webpack打包流程!!!!!!**
1. 初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数； 
2. 开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译； 
3. 确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件； 
4. 编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理； 
5. 完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 
6. 输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会； 
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统
**4plus. webpack的loader和plugins的区别!!!!!!**
Loader
作用：Loader 用于转换文件。它们主要处理模块的文件内容，将文件从一种格式转换为另一种格式，例如将 TypeScript 转换为 JavaScript，或者将 SCSS 转换为 CSS。
使用时机：Loader 在模块打包之前生效，属于一种预处理的机制。
工作方式：每个 Loader 只专注于对某种类型文件的转换，直接作用于文件内容。
例子：
babel-loader：将 ES6+ 代码转换为 ES5。
css-loader：处理 CSS 文件并解决 @import 和 url() 等语法。
Plugin
作用：Plugins 用于扩展 Webpack 的功能，并在打包的不同阶段执行复杂任务，如优化打包文件、资源管理、注入环境变量等。
使用时机：Plugin 的工作范围更加广泛，它们可以在整个编译过程中的不同阶段运行。
工作方式：Plugin 能够访问 Webpack 的编译生命周期，在编译的各个钩子上进行复杂的操作。它们不仅限于处理文件，还可以操作资源、修改配置等。
Loader：专注于处理单个文件的内容，在模块系统中对文件进行转换。
Plugin：用于扩展 Webpack 功能，可以在整个构建过程中执行复杂任务，如优化、生成文件等。 

**5.浏览器从输入url到显示出页面发生了什么事!!!!!!**
（1）解析URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
（2）缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
（3）DNS解析：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
（4）获取MAC地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
（5）TCP三次握手：下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
（6）HTTPS握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
（7）返回数据：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
（8）页面渲染：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
（9）TCP四次挥手：最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
6.vue的生命周期
6plus. vue的更新流程
7.vue的双向数据绑定
8.算法题: 二分查找
9.编程题: 防抖 debounce

## 面经4
一面
**1.如何从0到1搭建项目!!!!!!**
2.事件循环
3.js数据类型
4.引用类型和原始值的区别
5.如何判断数据类型
6.call，apply，bind的区别联系
7.如何理解异步，Promise，generator，async await的使用
8.跨域
9.fiber的理解
10.key的作用
11.常用的hooks
12.值输出：一道this指向，一道事件循环
13.手写：实现flat，实现filter

二面
面试官不是上一次的面试官，人也挺好的，总体来说我觉得我表现的一般，很多原理没有真正掌握
1.项目从0到1构建的吗，用的什么
2项目成员和分工，如何技术选型
3.t.ailwind css和普通css的区别，优势，什么时候不用tailwind
**4.vite和webpack的区别**
Webpack: Webpack的构建速度相对较慢，尤其在大型项目中，因为它需要分析整个依赖图，进行多次文件扫描和转译。
Vite: Vite以开发模式下的极速构建著称。它利用ES模块的特性，只构建正在编辑的文件，而不是整个项目。这使得它在开发环境下几乎是即时的。
⭐开发模式⭐
Webpack: Webpack通常使用热模块替换（HMR）来实现快速开发模式，但配置相对复杂。
Vite: Vite的开发模式非常轻量且快速，支持HMR，但无需额外配置，因为它默认支持。
⭐配置复杂度⭐
Webpack: Webpack的配置相对复杂，特别是在处理不同类型的资源和加载器时。
Vite: Vite鼓励零配置，使得项目起步非常简单，但同时也支持自定义配置，使其适用于复杂项目。
⭐插件生态⭐
Webpack: Webpack拥有庞大的插件生态系统，适用于各种不同的需求。
Vite: Vite也有相当数量的插件，但相对较小，因为它的开发模式和构建方式减少了对一些传统插件的需求。
⭐编译方式⭐
Webpack: Webpack使用了多种加载器和插件来处理不同类型的资源，如JavaScript、CSS、图片等。
Vite: Vite利用ES模块原生支持，使用原生浏览器导入来处理模块，不需要大规模的编译和打包。
⭐应用场景⭐
Webpack: 适用于复杂的大型项目，特别是需要大量自定义配置和复杂构建管道的项目。
Vite: 更适用于小到中型项目，或者需要快速开发原型和小型应用的场景。
⭐打包原理⭐
Webpack: Webpack的打包原理是将所有资源打包成一个或多个bundle文件，通常是一个JavaScript文件。
Vite: Vite的打包原理是保持开发时的模块化结构，使用浏览器原生的导入机制，在生产环境中进行代码分割和优化

5.webpack loader和plugin的区别，他们的本质是什么
**6.前端性能优化怎么做，要关注什么指标**
在前端性能优化中，主要关注以下关键指标：
First Contentful Paint (FCP)：首次内容渲染的时间。
Largest Contentful Paint (LCP)：最大可见元素渲染的时间。
First Input Delay (FID)：首次交互的响应延迟。
Cumulative Layout Shift (CLS)：页面视觉稳定性，避免布局偏移。
Time to First Byte (TTFB)：服务器响应时间

7.publicPath的意义
8.HTTP 1.1 & HTTP 2.0
9.代码实现：一道curry，一道数组转树形

## 面经5
1.html 有哪些语义化标签，以及好处
2.深色主题切换实现的思路
3.博客右上角随机文章怎么实现的
**4.觉得 vue/react 对比原生有哪些好处**

5.数组的常见方法
**6.Array(100).map(x=>1)，输出是什么，以及有哪些方式可以实现这个 我回答的是 100 个 1，实际是 100 个空map 不够熟悉**
Array(100).map(x => 1) 的输出是一个包含 100 个 undefined 的数组，而不是一个填充了 1 的数组。
原因如下：
Array(100) 创建了一个长度为 100 的稀疏数组，但这些元素没有被初始化。这意味着它们是“空的”，即数组中没有实际的值。
map()方法会对数组中的每一个**已存在**的值调用回调函数。但在稀疏数组中，那些“空位”是不会被 map() 遍历的。因此，x => 1 这个回调函数根本没有被执行。

7.如何将对象转字符串，JSON.stringify()，以及参数控制缩进
8.tailwind、unocss、原生 css 区别好处
**9.http 常见请求头 content type回答的不够多**
● Accept:浏览器能够处理的内容类型
● Accept-Charset:浏览器能够显示的字符集
● Accept-Encoding：浏览器能够处理的压缩编码
● Accept-Language：浏览器当前设置的语言
● Connection：浏览器与服务器之间连接的类型
● Cookie：当前页面设置的任何Cookie
● Host：发出请求的页面所在的域
● Referer：发出请求的页面的URL
● User-Agent：浏览器的用户代理字符串

HTTP Responses Header 常见的响应头：
● Date：表示消息发送的时间，时间的描述格式由rfc822定义
● server:服务器名称
● Connection：浏览器与服务器之间连接的类型
● Cache-Control：控制HTTP缓存
● content-type:表示后面的文档属于什么MIME类型
Host
Conection
chache-control
cookie
referer
accept
accept-language
accept-ecoding
content- type
conste-language
content-encoding
if-modified-since
if-none-match

10.package.json，tsconfig 常见配置 tsconfig 不够多
**11.webpack 打包编译流程 了解不足**
12.tailwind 统一配置怎么做的
**13.移动端如何与端上交互，js bridge，jsb 的具体实现了解吗**
js无返直接调用原生的api，所以原生封装jsb，js调用jsb来调用原生的api，
具体实现类似 在webview浏览器内核 注册全局api（window）和 URL Scheme iframe（通过特定的url与原生进行交互，iframe）

**14.性能优化、图片懒加载 图片懒加载需要了解一下**
初始加载：在页面初始加载时，只加载可见区域的图片。其他图片的加载会被推迟。
滚动检测：通过监听用户的滚动事件，当用户向下滚动到图片的位置时，触发加载相应的图片。
占位符：在懒加载的图片位置可以使用占位符（如低分辨率图片或颜色块）来保持布局稳定。
通过一些现成的库（如 lazysizes、react-lazyload）来实现懒加载。

15.工程化相关